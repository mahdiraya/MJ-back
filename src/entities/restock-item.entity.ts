// src/entities/restock-item.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  ManyToOne,
  OneToMany,
  Column,
  JoinColumn,
} from 'typeorm';
import { Restock } from './restock.entity';
import { Item } from './item.entity';
import { RestockRoll } from './restock-roll.entity';

// keep decimals as numbers in JS
const dec2 = {
  to: (v: any) => v,
  from: (v: any) => (v == null ? 0 : Number(v)),
};
const dec3 = {
  to: (v: any) => v,
  from: (v: any) => (v == null ? null : Number(v)),
};

@Entity('restock_items')
export class RestockItem {
  @PrimaryGeneratedColumn()
  id!: number;

  @ManyToOne(() => Restock, (r) => r.restockItems, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'restock_id' })
  restock!: Restock;

  @ManyToOne(() => Item, { eager: true })
  @JoinColumn({ name: 'item_id' })
  item!: Item;

  /** EACH = piece-based, METER = meter-based */
  @Column({ type: 'enum', enum: ['EACH', 'METER'] })
  mode!: 'EACH' | 'METER';

  /** For EACH we store quantity; for METER we usually keep this 1 */
  @Column({ type: 'int', default: 1 })
  quantity!: number;

  /** For METER rows, the length for this line (optional for EACH) */
  @Column({
    type: 'decimal',
    precision: 10,
    scale: 3,
    nullable: true,
    transformer: dec3,
  })
  length_m!: number | null;

  /** Purchase price per unit (piece or meter) */
  @Column({
    type: 'decimal',
    precision: 10,
    scale: 2,
    transformer: dec2,
  })
  price_each!: number;

  /**
   * Generated by the DB:
   * CASE WHEN mode='METER' THEN price_each*COALESCE(length_m,0)
   *      ELSE price_each*quantity END
   *
   * TypeORM will NOT include it in INSERT/UPDATE.
   */
  @Column({
    type: 'decimal',
    precision: 10,
    scale: 2,
    asExpression:
      "CASE WHEN `mode` = 'METER' THEN `price_each` * COALESCE(`length_m`, 0) ELSE `price_each` * `quantity` END",
    generatedType: 'STORED',
    select: true,
    transformer: dec2,
  })
  line_total!: number;

  /** Inverse side for per-roll details */
  @OneToMany(() => RestockRoll, (rr) => rr.restockItem, { cascade: true })
  rolls!: RestockRoll[];
}
